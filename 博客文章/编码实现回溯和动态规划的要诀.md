# 编码实现回溯和动态规划的要诀

2020.02.20 王谭旭

## 回溯
递归树
```python
def back_track(node):
	# 递归结束条件
	if ...

	# 剪枝
	...
	
	back_track(node.left)
	back_track(node.right)
```

## 动态规划
回溯算法的时间复杂度为指数级，使用动态规划来避免重复计算，两种思路：

- 状态转移表（填表）

	场景：女朋友的购物车有100个宝贝，加一张满500减100的优惠券，帮她选出一些总价凑近500元的宝贝


	|宝贝\总价|  0 |   1| 2|3|4|5|6|...|600|
	| -------- | --------|------|---|---|---|---|---|---|---|
	| n1|   1（不买）|  0|1（买）|0|0|0|0|...|0|
	| n2|   1|  0|1（不买）|0|0|1（买）|0|...|0|
	|...|
	|n100|


- 状态转移方程（递推公式）

	场景：一张i x j大小的地图map，找出从（0，0）到（i，j）的最短路径

	递推公式：

	```python
	min_dist(i, j) = min(min_dist(i - 1, j), min_dist(i, j - 1)) + map(i, j)
	```
